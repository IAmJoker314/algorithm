- 面试沟通
    (1)面试时，要经常和面试官沟通。沟通好题目条件、问题的意图之后再动手coding或者回答问题。
    (2)面试中，若面试官提出新的概念，面试者需要和面试官积极沟通，多问几个问题，把概念搞清楚。
    (3)面试中，若有多种解法，且多种解法各有优缺点，则需要和面试官沟通，确定问题需要的最合适的解法。
    (4)考虑性能的时候，是关注时间还是空间？其复杂度要求是多少？
        考虑实现的时候，是否可以修改原来的结构？是否可以在新的结构中操作?

- 排序和查找
    --查找：顺序查找 二分查找 哈希表查找 二叉排序树（其实就是二叉搜索树）查找
    (1) 二分查找：要求在排序或者是部分排序的数组中查找一个数字或者统计某个数字出现的次数，可以尝试二分查找。
    (2) 哈希表&二叉排序树：重点在于考察数据结构本身，不在于算法
    (3) 哈希表：优点是能够在O(1)内找到某一个元素，是效率最高的查找方式。缺点是需要额外空间实现哈希表。

    -- 排序：插入排序 冒泡排序 归并排序 快速排序
    关注其实现，性能，场景等

- 回溯法：
    （1）类似于暴力解答
    （2）常常使用递归，回溯法很适合递归实现。递归可以用栈来模拟。
    注：二维数组或者迷宫问题，可以尝试回溯法。

- 递归与循环：
    (1)递归：由于递归实现更加简洁，若没有特殊要求，可以优先选用递归实现。
    效率问题：递归可能存在大量的重复运算，因此性能可能弱于循环。如：Ex_10_Fibonacci
    栈溢出问题：递归还可能引起调用栈溢出的问题。

    (2)思考：一般用递归的方式思考答案，用循环的方式实现代码。

- 动态规划
    （1）动态规划多可以用递归解决；
    （2）但是递归中有很多需要重复计算的项，如Ex_10_Fibonacci
    （3）动态规划从下到上，将重复的子问题的答案存储起来，减少了重复计算的时间浪费，但是增加了空间的消耗。

- 贪心算法

- 说明
    (1) 若求某个问题的最优解，且该问题可以分解为多个子问题，则可以尝试动态规划。
    递归操作是自上而下，动态规划则是自下而上，避免不必要的重复计算。
    若是某个问题有特殊的选择，那么这个问题的最优解可能就是贪婪算法得出的。
    (2) 思考路线：递归->动态规划->贪婪算法

- 位运算
    (1) 基本运算：与、或、异或、左移、右移
    (2) 把一个整数减1之后再和原来的整数做位与运算，相当于将整数的二进制表示中的最右边的1变成0：
    x = (x - 1) & x : 将x的二进制最右边的1变成了0

- 高质量的代码
    -- 代码的规范性
    （1）书写清晰
    （2）布局清晰
    （3）命名合理
    -- 代码的完整性
    （1）功能测试：基本功能
    （2）边界测试：边界值
    （3）负面测试：非法值

    -- 代码的鲁棒性：程序对输入的合法性判断以及对非法输入的处理
        --- 容错性
        --- 防御性编程

    --注：在处理链表问题时，当我们用一个指针遍历链表无法解决问题时，可以尝试用2个指针解决问题。
    可以让一个指针遍历的速度快一点（一次走2步，或者先走若干步），让另外一个指针遍历的速度慢一点

     --注：
        （1）若面试题是关于n位的整数且没有限定n的取值范围，或者输入任意大小的整数，则此题目可能需要考虑大数问题。
        （2）大数问题如何处理？字符串是一种有效的地表示大数地方法。
        （3）例：Ex_17_AddTwoBigNumber

- 解决面试题的思路
    -- 在解决笔试或者面试题目之前，应该思考清楚题目的解决思路，然后再进行编码。

    -- 画图
    -- 举例
    -- 分解

    -- 注：
    1. 二叉树遍历
        -- 先序             Stack T26:树的子结构; T7:重建二叉树 T37：树的序列化和反序列化
        -- 中序             Stack T7:重建二叉树
        -- 后序             Stack T33:判断一个序列是否是BST的后序（先序）遍历序列；
        -- Morris遍历       Stack
        -- 宽度优先遍历：层遍历（也叫广度优先遍历）T32：从上到下打印二叉树
            -- 不分行       Queue
            -- 分行         Queue + 记录节点
            -- 之字形       Stack * 2
        -- 深度优先遍历：先序遍历   T34：二叉树中和为某一个值的路径

    2. 二叉树分类
        -- 二叉搜索树
        -- 红黑树
        -- 二叉堆
    3. 技巧：
        -- 若要求处理二叉树的遍历序列，则可以先找到二叉树的根节点，
        然后基于根节点将二叉树的遍历序列分成左子树和右子树对应的子序列 分界：i
        然后递归处理这2个子序列.模式如下
        process(sequence, start, end)
        -> process(sequence, start, i-1)
        -> process(sequence, i, end)
            --- 例如：面试题33：判断一个序列是否是BST的后序（先序）遍历序列；
                      面试题7：重建二叉树

- 优化时间和空间效率

-- 注：若需要判断多个字符是否在某个字符串中出现过或者统计其出现的次数，考虑哈希表，或者考虑基于数组创建一个简单的哈希表，
这样可以用很小得空间消耗换来时间效率的提升。

-- 如何降低时间复杂度？
1. 改用更高效的算法
2. 空间换时间


-- 递归与动态规划

- 面试考察能力

--编程能力
--学习能力
--抽象建模能力
--发散思维能力
--知识迁移能力
--沟通能力

*******************************************************
- 编写程序时需要考虑的一些问题：
-- 关注鲁棒性：边界条件 特殊输入 错误处理等
-- 编写过程：
   测试用例
   -> 找出规律
   -> 编程
   -> 检验 （基本功能、边界条件、错误处理）
   -> 优化