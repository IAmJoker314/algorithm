# Summary

##  数组

* 数组（Array）：数组是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同数据类型**的数据。
  * 线性表与非线性表
    * 线性表（Linear List）：数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后2个方向。如：数组、链表、队列、栈等。
    * 非线性表：数据之间不是简单的前后关系。如：二叉树、堆、图等。
  * 连续的内存空间和相同类型的数据
    * 正是因为这2个限制，数组具有一个杀手级的特性：**随机访问**。即其根据下标随机访问的时间复杂度为O(1)。但是要**注意**数组中查找一个元素的时间复杂度不是O(1)。
    * 但是也正是因为数组存储需要连续的内存空间，因此其插入和删除操作非常低效，因为为了保证数组数据的连续性，需要做大量的数据搬移工作。
* 数组的插入、删除
  * 插入：
    * 实现：将某个元素插入到数组第k个位置，需要将k~n部分的元素向后搬移一位，然后插入元素。若插入到数组的末尾，时间复杂度O(1)；插入到数组的开头，时间复杂度O(n)；插入的平均时间复杂度为（1+2+...+n）/n = O(n)。
    * **优化**：若数组只是一个存储数据的集合，其元素是无序的，则插入时不需要搬移数据。此时若想将某个元素插入到数组第k个位置，首先将该位置的元素移动到数组末尾，然后将待插入元素插入到第k个位置，时间复杂度降为O(1)。但是要注意这个优化是针对数组是无序的。
  * 删除
    * 实现：若要删除第k个位置的元素，则需要将k+1~n个元素向前搬移一位。若删除数组的末尾，时间复杂度O(1)；删除数组的开头，时间复杂度O(n)；删除平均时间复杂度为 O(n)。
    * **优化**：将多次删除一起执行。当我们要删除多个元素的时候，并不立即进行搬移操作，而是将多个元素标记为已删除，然后当数组满了的时候，将标记的元素一起删除，这样就减少了数组搬移的次数，提高了效率。这就是JVM中标记-清除算法的核心思想。
* 数组的内存模型
  * 访问数组的本质：访问一段连续内存。
  * 数组访问寻址公式：
    * 给定一维数组`a[n]`, 则`a[k]`的内存地址为：`a[k]_address = base_address + k * type_size`。
    * 给定二维数组`a[m][n]`则`a[i][j]`的内存地址为：`a[i][j]_address = base_address + (i*n + j) * type_size `。

## 排序

| 排序方法 | 最好       | 最坏       | 平均       | 额外空间复杂度 | 稳定性 | 原地排序 |
| -------- | ---------- | ---------- | ---------- | -------------- | ------ | -------- |
| 冒泡     | O(n)   | O(n^2)  | O(n^2)   | O(1)         | 是     | 是       |
| 插入     | O(n)    | O(n^2)   | O(n^2)   | O(1)         | 是     | 是       |
| 选择     | O(n^2)   | O(n^2)   | O(n^2)   | O(1)         | 否     | 是       |
| 归并     | O(nlogn) | O(nlogn) | O(nlogn) | O(n)         | 是     | 否       |
| 快排     | O(nlogn) | O(n^2)   | O(nlogn) | O(1)         | 否     | 是       |

