# Summary

##  数组

* 数组（Array）：数组是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同数据类型**的数据。
  * 线性表与非线性表
    * 线性表（Linear List）：数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后2个方向。如：数组、链表、队列、栈等。
    * 非线性表：数据之间不是简单的前后关系。如：二叉树、堆、图等。
  * 连续的内存空间和相同类型的数据
    * 正是因为这2个限制，数组具有一个杀手级的特性：**随机访问**。即其根据下标随机访问的时间复杂度为O(1)。但是要**注意**数组中查找一个元素的时间复杂度不是O(1)。
    * 但是也正是因为数组存储需要连续的内存空间，因此其插入和删除操作非常低效，因为为了保证数组数据的连续性，需要做大量的数据搬移工作。
* 数组的插入、删除
  * 插入：
    * 实现：将某个元素插入到数组第k个位置，需要将k~n部分的元素向后搬移一位，然后插入元素。若插入到数组的末尾，时间复杂度O(1)；插入到数组的开头，时间复杂度O(n)；插入的平均时间复杂度为（1+2+...+n）/n = O(n)。
    * **优化**：若数组只是一个存储数据的集合，其元素是无序的，则插入时不需要搬移数据。此时若想将某个元素插入到数组第k个位置，首先将该位置的元素移动到数组末尾，然后将待插入元素插入到第k个位置，时间复杂度降为O(1)。但是要注意这个优化是针对数组是无序的。
  * 删除
    * 实现：若要删除第k个位置的元素，则需要将k+1~n个元素向前搬移一位。若删除数组的末尾，时间复杂度O(1)；删除数组的开头，时间复杂度O(n)；删除平均时间复杂度为 O(n)。
    * **优化**：将多次删除一起执行。当我们要删除多个元素的时候，并不立即进行搬移操作，而是将多个元素标记为已删除，然后当数组满了的时候，将标记的元素一起删除，这样就减少了数组搬移的次数，提高了效率。这就是JVM中标记-清除算法的核心思想。
* 数组的内存模型
  * 访问数组的本质：访问一段连续内存。
  * 数组访问寻址公式：
    * 给定一维数组`a[n]`, 则`a[k]`的内存地址为：`a[k]_address = base_address + k * type_size`。
    * 给定二维数组`a[m][n]`则`a[i][j]`的内存地址为：`a[i][j]_address = base_address + (i*n + j) * type_size `。

## 排序

| 排序方法 | 最好       | 最坏       | 平均       | 额外空间复杂度 | 稳定性 | 原地排序 |
| -------- | ---------- | ---------- | ---------- | -------------- | ------ | :------: |
| 冒泡     | O(n)   | O(n^2)  | O(n^2)   | O(1)         | 是     | 是       |
| 插入     | O(n)    | O(n^2)   | O(n^2)   | O(1)         | 是     | 是       |
| 选择     | O(n^2)   | O(n^2)   | O(n^2)   | O(1)         | 否     | 是       |
| 归并     | O(nlogn) | O(nlogn) | O(nlogn) | O(n)         | 是     | 否       |
| 快排     | O(nlogn) | O(n^2)   | O(nlogn) | O(1)         | 否     | 是       |
| 桶排 | O(n) | - | - | - | 是 | 否 |
| 计数 | O(n+k)(k是数据范围) | - | - | - | 是 | 否 |
| 基数 | O(d*n)(d是维度) | - | - | - | 是 | 否 |



## 二分查找

* 二分查找：高效的有序数据集合查找算法
  * 时间复杂度：O(logn)
  * O(logn)是一个快到很恐怖复杂度。例如：当n=2^32（约42亿）时，logn=32。即从42亿有序数据中二分查找一个数据，最多32次。相反，O(2^n)是一个慢的恐怖的时间复杂度。
* 应用场景：
  * 针对数组，原因是：
    * 数组：根据下标随机访问的时间复杂度O(1)
    * 链表：根据下标随机访问的时间复杂度O(n)
  * 针对有序数据
    * 二分查找只能用在插入、删除操作不频繁的静态数据中，一次排序多次查找的场景中，因为排序最快O(nlogn)
    * 那么动态数据集合如何快速查找某个数据呢？答案是二叉树。
  * 数据量太小不适合二分查找
    * 数据量太小，直接顺序遍历即可，二分查找的优势并不明显
    * 但是如果数据之间的比较操作比较耗时间，那么减少比较操作会大大提高性能，因此即使数据量小，但是二分查找可以减小比较次数，例如数组中存储的是长度超过300的字符串，这样长度的字符串的比较则会非常耗时间。
  * 数据量太大不适合二分查找
    * 二分查找需要依赖数组，而数组为了支持随机访问的特性，要求内存空间是连续的，因此对内存的要求比较苛刻。比如，要存储1GB的数据，则需要1GB的连续内存空间。
    * 这里的**连续**是指：即使有2GB内存空间剩余，但是这些空间是零散的，没有连续的1GB的空间，那照样无法申请一个1GB的数组。
* 问题：假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？
  * 1000 * 10^4 * 8 / 10^6 = 80MB，可以使用数组存储80MB的整数，然后排序，使用二分查找取得某个数据。
  * 大部分情况下，使用二分查找可以解决的问题，散列表和二叉树也可以解决，那么是否可以用散列表或者二叉树呢？答案是否定的。因为散列表和二叉树都需要额外的存储，100MB必然不够。